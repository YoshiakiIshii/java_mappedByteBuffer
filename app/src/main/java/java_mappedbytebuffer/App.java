/*
 * This source file was generated by the Gradle 'init' task
 */
package java_mappedbytebuffer;

import com.opencsv.CSVReader;
import com.opencsv.exceptions.CsvValidationException;
import java.io.RandomAccessFile;
import java.io.File;
import java.nio.channels.FileChannel;
import java.nio.MappedByteBuffer;
import java.nio.charset.StandardCharsets;
import java.io.FileReader;
import java.io.FileWriter;
import com.opencsv.CSVWriter;
import java.io.IOException;
import java.util.HashMap;
import java.util.ArrayList;
import java.util.List;

public class App {

    private static MappedByteBuffer createBufferFile(List<File> bufferFiles, int bufferSize) throws IOException {
        File tempFile = File.createTempFile("mergebuffer", ".tmp");
        tempFile.deleteOnExit();
        bufferFiles.add(tempFile);
        try (RandomAccessFile raf = new RandomAccessFile(tempFile, "rw");
                FileChannel channel = raf.getChannel()) {
            return channel.map(FileChannel.MapMode.READ_WRITE, 0, bufferSize);
        }
    }

    public static String[] readBufferArray(List<MappedByteBuffer> buffers, String mapValue) {
        if (mapValue == null)
            return new String[0];
        String[] parts = mapValue.split(":");
        int bufIdx = Integer.parseInt(parts[0]);
        int pos = Integer.parseInt(parts[1]);
        MappedByteBuffer buf = buffers.get(bufIdx);
        buf.position(pos);
        // 先頭に格納されている配列要素数を取得
        if (buf.remaining() < 4)
            return new String[0];
        int arrayLen = buf.getInt();
        List<String> result = new ArrayList<>();
        for (int i = 0; i < arrayLen; i++) {
            if (buf.remaining() < 4)
                break;
            int len = buf.getInt();
            if (buf.remaining() < len)
                break;
            byte[] bytes = new byte[len];
            buf.get(bytes);
            result.add(new String(bytes, StandardCharsets.UTF_8));
        }
        return result.toArray(new String[0]);
    }

    public static void main(String[] args) {
        long startTime = System.currentTimeMillis();
        if (args.length != 3) {
            System.err.println("Usage: java App <baseFile> <mergeFile> <outputFile>");
            System.exit(1);
        }

        String baseFile = args[0];
        String mergeFile = args[1];
        String outputFile = args[2];

        HashMap<String, Object> map = new HashMap<>();

        try (CSVReader reader = new CSVReader(new FileReader(baseFile))) {
            String[] line;
            while ((line = reader.readNext()) != null) {
                if (line.length < 2)
                    continue;
                String key = line[0] + "|" + line[1];
                map.put(key, null);
            }
        } catch (IOException | CsvValidationException e) {
            e.printStackTrace();
        }

        int bufferSize = 1024 * 1024; // 初期サイズ1MB
        List<MappedByteBuffer> buffers = new ArrayList<>();
        List<File> bufferFiles = new ArrayList<>();
        int currentBufferIndex = 0;
        int currentPos = 0;

        try {
            buffers.add(createBufferFile(bufferFiles, bufferSize));
        } catch (IOException e) {
            e.printStackTrace();
            return;
        }

        try (CSVReader mergeReader = new CSVReader(new FileReader(mergeFile))) {
            String[] mergeLine;
            while ((mergeLine = mergeReader.readNext()) != null) {
                if (mergeLine.length < 3)
                    continue;
                String key = mergeLine[0] + "|" + mergeLine[1];
                if (map.containsKey(key)) {
                    if (map.get(key) == null) {
                        // 3項目目以降を文字列配列として格納
                        int arrayLen = mergeLine.length - 2;
                        int totalBytes = 4; // 先頭に配列要素数
                        byte[][] valueBytesArr = new byte[arrayLen][];
                        for (int i = 2; i < mergeLine.length; i++) {
                            valueBytesArr[i - 2] = mergeLine[i].getBytes(StandardCharsets.UTF_8);
                            totalBytes += 4 + valueBytesArr[i - 2].length; // 4byte:長さ情報
                        }

                        // バッファサイズ超過時は新バッファ作成（共通メソッド利用）
                        if (currentPos + totalBytes > bufferSize) {
                            try {
                                buffers.add(createBufferFile(bufferFiles, bufferSize));
                            } catch (IOException e) {
                                e.printStackTrace();
                                break;
                            }
                            currentBufferIndex++;
                            currentPos = 0;
                        }

                        MappedByteBuffer buf = buffers.get(currentBufferIndex);
                        buf.position(currentPos);
                        buf.putInt(arrayLen); // 先頭に配列要素数
                        for (byte[] valueBytes : valueBytesArr) {
                            buf.putInt(valueBytes.length);
                            buf.put(valueBytes);
                        }
                        // マップにはバッファ番号と位置をセットで登録
                        map.put(key, currentBufferIndex + ":" + currentPos);
                        currentPos += totalBytes;
                    }
                    // 値がnull以外の場合は何もしない
                }
                // 存在しない場合は何もしない
            }
        } catch (IOException | CsvValidationException e) {
            e.printStackTrace();
        }
        // ベースファイルを再度読み込み、出力ファイルにCSV形式で書き出し
        try (CSVReader reader = new CSVReader(new FileReader(baseFile));
                CSVWriter writer = new CSVWriter(new FileWriter(outputFile))) {
            String[] line;
            while ((line = reader.readNext()) != null) {
                if (line.length < 2) {
                    writer.writeNext(line);
                    continue;
                }
                String key = line[0] + "|" + line[1];
                Object mapValue = map.get(key);
                String[] concatArr = null;
                if (mapValue != null) {
                    concatArr = readBufferArray(buffers, mapValue.toString());
                }
                // ベース配列＋結合バッファ配列を連結
                String[] outArr;
                if (concatArr != null && concatArr.length > 0) {
                    outArr = new String[line.length + concatArr.length];
                    System.arraycopy(line, 0, outArr, 0, line.length);
                    System.arraycopy(concatArr, 0, outArr, line.length, concatArr.length);
                } else {
                    outArr = line;
                }
                writer.writeNext(outArr);
            }
        } catch (IOException | CsvValidationException e) {
            e.printStackTrace();
        }
        // ヒープ使用量と最大ヒープサイズを出力
    long endTime = System.currentTimeMillis();
    long usedMemory = Runtime.getRuntime().totalMemory() - Runtime.getRuntime().freeMemory();
    long maxMemory = Runtime.getRuntime().maxMemory();
    System.out.println("Used heap: " + usedMemory + " bytes");
    System.out.println("Max heap: " + maxMemory + " bytes");
    System.out.println("Number of merge buffers created: " + buffers.size());
    System.out.println("Elapsed time: " + (endTime - startTime) + " ms");
    }
}
